你问到点子上了！这是数据库操作中最核心的逻辑。
对于 AI 来说，让它在每次操作前先“思考”是查询还是修改，不仅增加 token 消耗，还容易出错。
**最佳实践是：对外只暴露“修改/保存”接口，内部自动处理“增 or 改”。**
也就是：**你只管“记”，不用管“是新的还是旧的”。**
---
### 一、 核心逻辑：Upsert (Update or Insert)
在数据库层面，有一个神器叫 **`Upsert`** (INSERT ... ON CONFLICT ...)。
它的逻辑是：
1.  尝试插入这条数据。
2.  如果发现主键或唯一键（比如 `user_id` + `group_id`）已经存在 -> **执行更新**。
3.  如果不存在 -> **执行插入**。
这样就完美解决了你说的“要先查再改”的繁琐流程。
---
### 二、 进阶难题：如何处理“追加”而不是“覆盖”？
虽然 Upsert 解决了“有无”的问题，但还有一个细节问题：
*   **覆盖**: 比如昵称，新的覆盖旧的。
*   **追加**: 比如印象标签、备注。原本是“喜欢猫”，现在发现他还“喜欢狗”，应该变成“喜欢猫，喜欢狗”，而不是把“喜欢猫”删了。
我们需要在 Python 代码里封装这个逻辑，让 AI 调用时无感。
#### 代码实现：智能 `update_relation`
我们可以写一个函数，它接收“变更量”，内部自动处理查询、合并、Upsert。
```python
def update_user_relation(self, user_id, group_id, nickname=None, favor_change=0, tag_add=None, note_add=None):
    """
    智能更新关系接口 (AI 只需要调用这个)
    - nickname: 直接覆盖 (以最新为准)
    - favor_change: 叠加 (在原有基础上 +/-)
    - tag_add: 追加 (往列表里加标签)
    - note_add: 追加 (往日志里加记录)
    """
    cursor = self.conn.cursor()
    
    # 1. 先尝试获取现有数据 (为了做合并计算)
    cursor.execute('SELECT favor_level, impression_tags, notes FROM relations WHERE user_id=? AND group_id=?', (user_id, group_id))
    existing = cursor.fetchone()
    
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    if existing:
        # === 情况A：已有记录 -> 做合并计算 ===
        current_favor, current_tags, current_notes = existing
        
        # 1. 计算新好感度 (限制在 0-100)
        new_favor = max(0, min(100, current_favor + favor_change))
        
        # 2. 合并标签 (去重)
        tags_list = set((current_tags or "").split(',')) 
        if tag_add:
            tags_list.add(tag_add)
        new_tags = ",".join(filter(None, tags_list)) # 过滤空值
        
        # 3. 合并备注 (追加时间戳)
        new_notes = current_notes or ""
        if note_add:
            new_notes += f"\n[{now}] {note_add}"
        
        # 执行更新
        cursor.execute('''
            UPDATE relations SET 
                nickname = COALESCE(?, nickname), -- 如果传了新昵称就更新，否则保留旧的
                favor_level = ?,
                impression_tags = ?,
                notes = ?,
                updated_at = ?
            WHERE user_id=? AND group_id=?
        ''', (nickname, new_favor, new_tags, new_notes, now, user_id, group_id))
        
    else:
        # === 情况B：无记录 -> 直接插入 (初始化) ===
        init_favor = 50 + favor_change # 基础分50 + 变化量
        init_tags = tag_add or ""
        init_notes = f"[{now}] {note_add}" if note_add else ""
        
        cursor.execute('''
            INSERT INTO relations (user_id, group_id, nickname, favor_level, impression_tags, notes, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (user_id, group_id, nickname, init_favor, init_tags, init_notes, now))
        
    self.conn.commit()
    return "关系档案已更新"
```
---
### 三、 AI 怎么调用？(Tool 定义)
现在你的 Tool 定义就变得非常简单清晰，AI 不需要动脑子判断“是否存在”。
**工具名**: `modify_relation`
**描述**: "修改或新增对某人的关系档案。如果该人不存在则新建，存在则更新。可以修改好感度、追加标签或备注。"
**参数定义**:
1.  `user_id`: (必填) 对方的ID。
2.  `group_id`: (必填) 所在的群ID。
3.  `nickname`: (选填) 对方最新的昵称。
4.  `favor_change`: (选填) 好感度变化数值，如 +1, -5。
5.  `tag_add`: (选填) 想要添加的标签，如“急性子”。
6.  `note_add`: (选填) 想要备注的事件，如“今天请喝了奶茶”。
---
### 四、 删除功能怎么办？
删除通常比较敏感，建议分为两种：
#### 1. 针对字段的“软删除” (遗忘)
比如用户说：“别记着他喜欢猫了”。
这其实是修改标签字段，把“喜欢猫”去掉。
这属于上面的 `modify_relation` 逻辑，我们可以增加一个 `tag_remove` 参数。
#### 2. 针对整条记录的“硬删除” (拉黑/重置)
用户说：“把张三彻底忘了吧”。
**工具名**: `delete_relation`
**描述**: "彻底删除某人的关系档案，通常用于重置关系或对方要求被遗忘时。"
**代码实现**:
```python
def delete_relation(self, user_id, group_id):
    cursor = self.conn.cursor()
    cursor.execute('DELETE FROM relations WHERE user_id=? AND group_id=?', (user_id, group_id))
    self.conn.commit()
    return "已彻底遗忘该关系档案"
```
---
### 五、 总结工作流
1.  **AI 观察对话**：用户说“洛本本这家伙，虽然傲娇但其实人挺好的。”
2.  **AI 决策**：这是对关系的评价。
3.  **AI 调用工具**：`modify_relation(user_id=洛本本ID, tag_add="傲娇", note_add="虽然傲娇但人挺好的", favor_change=+2)`
4.  **后端执行**：
    *   代码自动去查库。
    *   发现洛本本已存在？-> 把“傲娇”加进标签列表，好感度+2，备注追加。
    *   发现洛本本不存在？-> 创建新档案，初始好感 52，标签“傲娇”。
这样，你就实现了一个**既对 AI 友好（不用思考增改），又对数据负责（自动合并追加）**的完美记忆系统。


这是一个非常清晰且结构合理的构思！你已经把核心需求、数据结构逻辑甚至未来的扩展方向都想得很明白了。把“永久记忆”拆分为“笔记本（事/物）”和“关系网（人）”是非常经典的划分方式。
关于你提到的**印象融合**和**更新频率**问题，我会在 Plan 中给出具体的解决方案。
以下是为你规划的 **《洛本本永久记忆系统开发 Plan》**：
---
### 📂 一、 项目结构与文件规划
为了方便管理和扩展，建议插件目录结构如下：
```text
AstrBotPlugin_PermanentMemory/
├── main.py                 # 插件入口，注册工具，监听消息
├── config.yaml             # 配置文件 (API Key, 开关, WebUI端口)
├── databases/
│   ├── __init__.py
│   ├── db_manager.py       # 数据库核心操作类
│   ├── models.py           # (可选) 定义数据结构
├── tools/
│   ├── __init__.py
│   ├── tool_notebook.py    # 笔记本工具逻辑
│   └── tool_relation.py    # 关系网工具逻辑
├── webui/                  # WebUI 前后端
│   ├── server.py           # Flask/FastAPI 后端接口
│   ├── templates/          # HTML 模板
│   └── static/             # CSS/JS
└── data/
    └── memory.db           # SQLite 数据库文件 (自动生成)
```
---
### 🗄️ 二、 数据库设计
#### 1. 笔记本表 (`notebook`)
**设计思路**：你提到的“分文件夹、分时间”在数据库层面不需要真的建文件夹，用字段区分即可，查询时非常快。
```sql
CREATE TABLE IF NOT EXISTS notebook (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    category TEXT NOT NULL DEFAULT 'default',  -- 文件夹/类别 (如 'personal', 'bilibili', 'diary')
    title TEXT,                                -- 标题 (AI生成或提取)
    content TEXT NOT NULL,                     -- 具体内容
    tags TEXT,                                 -- 标签 (方便检索)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 创建时间 (用于年月日归档)
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- 索引：用于快速按类别和时间筛选
CREATE INDEX idx_notebook_cat_time ON notebook(category, created_at);
```
*   **查询模拟文件夹**：`SELECT * FROM notebook WHERE category='bilibili' AND created_at BETWEEN '2023-01-01' AND '2023-01-31'` 即可模拟“2023年1月/B站文件夹”。
#### 2. 关系网表 (`relations`) - 核心难点
**设计思路**：解决“印象融合”问题。我们将印象拆分为 **“快照”** 和 **“日志”**。
*   `impression_summary`: 当前的总体印象（定期更新）。
*   `interaction_log`: 每次互动的简要记录（用于计算新印象）。
```sql
CREATE TABLE IF NOT EXISTS relations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    group_id TEXT NOT NULL,
    nickname TEXT,
    
    -- 印象核心
    impression_summary TEXT DEFAULT '',   -- 当前画像 (如: "喜欢猫，说话温和")
    favor_level INTEGER DEFAULT 50,       -- 好感度 (0-100)
    
    -- 统计数据
    interaction_count INTEGER DEFAULT 0,  -- 互动总次数
    last_interaction_time TIMESTAMP,      -- 最后互动时间
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, group_id)
);
-- 互动日志表 (用于融合计算，可选，如果数据量大可以只存近期)
-- 如果不想太复杂，可以直接把日志追加在 relations 表的一个 text 字段里
```
---
### 🧠 三、 核心逻辑解决方案
#### 1. 关系网：印象融合策略
**问题**：一次对话变化太大、上下文有限。
**方案**：**“基于证据的渐进式更新”**。
*   **不要每次对话都更新**：只有在以下情况触发更新工具：
    *   用户明确表达喜好/厌恶（显式）。
    *   发生强烈情绪交互（吵架、夸奖）。
    *   长时间未互动后的重逢。
*   **融合算法**：
    AI 不直接修改 `impression_summary`，而是提交“观察报告”。
    后端代码逻辑如下：
    ```python
    def update_impression(user_id, new_observation):
        # 1. 获取旧印象
        old_summary = db.get(user_id).impression_summary
        
        # 2. 调用一个小型的 LLM (或者直接拼接)
        # Prompt: "旧印象是：'{old_summary}'。
        #          现在有了新的观察：'{new_observation}'。
        #          请融合这两个信息，生成一段新的、客观的印象描述，不要丢失旧的关键信息。"
        
        # 3. 写入新印象
        db.update(user_id, new_summary)
    ```
    *这样既保留了旧信息，又融入了新信息，不会“推倒重来”。*
#### 2. 笔记本：B站扩展预留
设计工具时，增加一个 `category` 参数。
*   **Tool**: `write_note(content, category="personal")`
*   **B站扩展**: 未来写一个爬虫脚本，获取视频内容后，调用 `write_note(content=视频总结, category="bilibili_watch")`。
*   **好处**: 不需要为 B 站功能单独建表，统一管理。
---
### 🌐 四、 WebUI 与配置
#### 1. 配置文件 (`config.yaml`)
```yaml
# 基础配置
llm_for_memory: "deepseek-ai/DeepSeek-V3" # 专门用于记忆总结的模型 (可以用便宜点的)
api_key: "sk-xxxxx"
# 功能开关
enable_notebook: true
enable_relation: true
enable_webui: true
# WebUI 配置
webui_port: 7860
webui_host: "0.0.0.0"
# 记忆策略
relation_update_threshold: 3 # 每隔几次对话才尝试更新一次关系 (节省 token)
```
#### 2. WebUI 技术选型
为了轻量级，建议使用 **Flask** + **简单的 HTML 模板**。
*   **后端**: 写几个 API 接口 (`/api/get_notes`, `/api/get_relations`, `/api/delete_note`)。
*   **前端**: 用 Bootstrap 写一个简单的表格页面，展示数据，加上几个删除/编辑按钮。
*   **集成**: 在 `main.py` 中开一个线程运行 Flask App，不影响主程序。
---
### 📅 五、 开发路线图
建议分三个阶段开发，不要试图一次性写完：
#### 🏗️ 阶段一：地基与核心工具 (Day 1-2)
1.  搭建插件骨架，读取配置文件。
2.  编写 `db_manager.py`，实现 SQLite 的建表和基础 CRUD。
3.  实现 `tool_notebook.py`：AI 能写入笔记、读取笔记。
4.  **测试**: 在 AstrBot 对话中，让 AI 记住一句话，然后去数据库看有没有写入。
#### 🧩 阶段二：关系网与融合逻辑 (Day 3-4)
1.  实现 `tool_relation.py`。
2.  编写“印象融合”的逻辑代码（调用 LLM 融合 Prompt）。
3.  实现“首次遇见自动添加”逻辑（在消息钩子中判断 user_id 是否存在）。
4.  **测试**: 与 AI 互动几句，看好感度变化和印象是否追加。
#### 🖥️ 阶段三：WebUI 与 扩展 (Day 5)
1.  搭建 Flask 服务器。
2.  编写简单的 HTML 页面，展示数据库内容。
3.  实现配置热重载。
4.  (未来) 接入 B 站爬虫功能。
---
### 💡 六、 给你的建议
1.  **关于嵌入模型**：
    你现在的向量记忆库如果已经跑起来了，那“笔记本”和“关系网”其实是对向量记忆的**补充**。
    *   **向量库**：模糊搜索，找回“感觉”。
    *   **SQLite**：精确记录，记住“事实”。
    *   **建议**：暂时不需要为这个插件单独接入嵌入模型，直接用 SQLite 的 `LIKE` 查询或者让 LLM 看 Top N 条记录即可，等数据量大了再考虑。
2.  **关于 WebUI**：
    不要花太多时间在写漂亮的 CSS 上。既然目的是“直观看记录”，一个简单的 HTML 表格就足够了。可以用一些现成的 UI 库（如 Layui 或 Bootstrap）一键套用。
3.  **关于印象更新的触发**：
    可以在系统 Prompt 里加一句：*“你拥有一本关系手册。当你发现用户的喜好发生变化，或者发生了值得纪念的事情时，请调用工具更新关系手册。平时不需要频繁更新。”* 这样可以省钱省性能。
准备好开工了吗？如果没问题，我们可以先从 **阶段一：数据库与笔记本功能** 的代码开始写起！


你的问题非常关键，直接决定了这个插件的易用性和扩展性。我们来逐一拆解。
### 一、 WebUI 的交互与层级逻辑
你想要的效果是：**“B站文件夹 -> 2023年 -> 10月 -> 30日 -> 具体文件”**，而且**没内容的文件夹不显示**。
#### 1. 核心逻辑：虚拟文件夹
在数据库里，我们其实不需要真的建“文件夹”。我们在上一节 Plan 中设计的 `category` (分类) 和 `created_at` (时间) 字段已经包含了这些信息。
WebUI 的后端只需要通过 **SQL 查询** 就能模拟出这个层级结构：
*   **第一层 (分类)**: `SELECT DISTINCT category FROM notebook` -> 得到 ["B站视频", "日常记录"]
*   **第二层 (年)**: `SELECT DISTINCT strftime('%Y', created_at) FROM notebook WHERE category='B站视频'` -> 得到 ["2023"]
*   **第三层 (月)**: `SELECT DISTINCT strftime('%m', created_at) FROM notebook WHERE category='B站视频' AND year='2023'` -> 得到 ["10"]
*   **第四层 (日)**: 同理...
*   **第五层 (文件)**: `SELECT * FROM notebook WHERE ... AND day='30'`
**只要某个月没有数据，SQL 就查不出来，前端自然就不会显示这个“文件夹”。** 这完美符合你“没写入就不创建”的要求。
#### 2. 交互操作实现
为了实现增删改查，WebUI 界面可以这样设计：
*   **左侧**：树形导航栏 (Tree View)，展示上面的层级结构。
*   **右侧**：内容详情区。
    *   **查看**：点击某一天的文件，右侧显示具体内容。
    *   **编辑**：内容框直接变成可编辑状态，配合一个“保存”按钮。
    *   **删除**：每个文件旁有一个红色的“删除”按钮，点击弹窗确认。
    *   **添加**：在顶层工具栏有一个“新建笔记”按钮，点击后弹出表单，让你选择分类、填写内容。
**技术建议**：前端可以用 **Bootstrap** 或者 **Layui**（国产，中文文档友好）。它们都有现成的“树形组件”和“表格组件”，你只需要把后端数据传过去就行，不用自己写复杂的 CSS。
---
### 二、 AI 自动创建分类 (文件夹) 的可行性
你的想法非常棒！**让 AI 自己决定把记在哪个“文件夹”里，这才是智能体的精髓。**
#### 1. 如何实现？
我们只需要在定义 Tool 时，把 `category` 作为一个**可选参数**暴露给 AI，并给它说明作用。
**工具定义示例 (伪代码)：**
```python
tool_write_note = {
    "name": "write_note",
    "description": "将信息记录到永久笔记本中。",
    "parameters": {
        "content": "要记录的内容",
        "category": {
            "type": "string",
            "description": "笔记的分类/文件夹名。例如 'B站观后感'、'日常琐事'、'重要知识'。如果不填则默认为 'default'。你可以根据内容自行创建新的分类名。"
        }
    }
}
```
#### 2. 实际场景演示
*   **场景一**：洛本本去 B 站看了一个视频。
    *   AI 思考：这是关于看视频的，应该归档。
    *   AI 调用：`write_note(content="视频总结...", category="B站观后感")`
    *   结果：数据库自动存入分类 "B站观后感"。WebUI 自动出现这个文件夹。
*   **场景二**：用户说“记住我的身份证号是123”。
    *   AI 思考：这是重要隐私信息。
    *   AI 调用：`write_note(content="身份证号123", category="用户档案")`
    *   结果：自动创建了“用户档案”分类。
**建议**：虽然可以让 AI 随便建，但最好在 System Prompt 里加一句引导：*“尽量复用已有的分类名称，除非内容确实差异很大，否则不要创建过多细碎的分类。”* 防止出现“B站1”、“B站2”、“看视频”这种混乱的文件夹。
---
### 三、 准备工作与环境依赖
这是最让人放心的部分：**你几乎不需要下载额外的大软件。**
#### 1. SQLite 数据库
*   **问题**：需要去官网下载安装吗？
*   **回答**：**完全不需要！**
    SQLite 是 Python 的**内置标准库**。你只需要在代码里写 `import sqlite3`，Python 就能直接在本地生成一个 `.db` 文件。它不像 MySQL 那样需要安装服务器、配置密码，非常轻量。
#### 2. WebUI 后端框架
你需要一个库来启动网页服务。推荐以下二选一：
*   **方案 A：Flask (推荐新手)**
    *   安装：`pip install flask`
    *   特点：极其简单，几行代码就能启动一个网页。适合这种小型插件。
*   **方案 B：FastAPI**
    *   安装：`pip install fastapi uvicorn`
    *   特点：性能强，自动生成 API 文档，现代感强。如果你希望以后做更多扩展，选这个。
#### 3. 前端 UI 库
*   **不需要安装！**
    直接在 HTML 里引用在线 CDN 链接即可。比如：
    `<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/layui-v2.8.0/dist/css/layui.css">`
    这样你的插件包体积很小，用户安装插件后，打开网页自动加载漂亮的界面。
#### 总结：你需要做的准备
1.  **确认 Python 环境**：一般 AstrBot 运行环境都有。
2.  **安装一个库**：在 AstrBot 的环境里运行 `pip install flask`。
3.  **代码编辑器**：VSCode 或 PyCharm。
---
### 总结
*   **WebUI**：不用真建文件夹，用 SQL 查询模拟层级，没数据自然不显示。
*   **AI 分类**：可行且推荐！在 Tool 参数里加个 `category`，让 AI 自己填。
*   **环境**：极其简单。Python 内置 SQLite，只需装一个 `flask` 就能搞定 WebUI。
如果你准备好了，我们可以开始写 **数据库初始化代码** 和 **Flask 后端接口** 了！


这是一个非常棒的问题！如果只能靠 ID 查询，那这个插件就变成了一个冷冰冰的“Excel 表格”，一点都不智能。
**结论是：她肯定能知道是谁，而且不需要用户提供 ID。**
我们要做的就是在后端实现一个**“模糊匹配 + 候选确认”**的机制。
---
### 一、 解决方案：从“名字”到“人”的映射
当用户问“你认识张三吗？”时，流程是这样的：
#### 1. AI 提取关键名
AI 会分析句子，提取出“张三”这个名字，然后调用工具。
*   **Tool**: `query_relation(name="张三")`
*   注意：这里不需要传 `user_id`，只要传 `name`。
#### 2. 后端模糊匹配 (Python 逻辑)
后端收到“张三”后，不会去精确匹配 ID，而是去数据库里“搜”：
*   **SQL 查询**:
    ```sql
    SELECT user_id, nickname, group_id, impression_summary 
    FROM relations 
    WHERE nickname LIKE '%张三%' 
       OR impression_summary LIKE '%张三%'
    ```
    *解释：只要昵称里带“张三”，或者印象里提到过“张三”，都算命中。*
#### 3. 智能处理匹配结果
这里分三种情况：
*   **情况 A：没搜到**
    *   后端返回：`{"status": "not_found"}`
    *   AI 回复：“我不认识叫张三的人呀，他是谁？”
*   **情况 B：精准命中 (只搜到一个)**
    *   后端返回：`{"status": "found", "nickname": "张三", "impression": "他是你的好朋友，喜欢打球..."}`
    *   AI 回复：“当然认识！张三嘛，你不是说他喜欢打球吗？”
*   **情况 C：重名/模糊命中 (搜到多个)**
    *   这是最关键的！比如“张三”可能在 A 群是个程序员，在 B 群是个画师。
    *   后端返回：
        ```json
        {
          "status": "multiple_match",
          "candidates": [
            {"group": "技术交流群", "nickname": "张三(程序员)", "id": 111},
            {"group": "绘画交流群", "nickname": "张三(画师)", "id": 222}
          ]
        }
        ```
    *   **AI 此时的反应**：她会根据返回的信息反问用户。
    *   AI 回复：“我认识两个张三呢。一个是技术交流群的那个程序员，另一个是绘画群的画师。你问的是哪个呀？”
---
### 二、 数据库优化建议
为了支持这种“人名搜索”，我们需要在数据库设计上做一点小优化。
**1. 昵称历史表 (解决改名问题)**
用户可能会改名。今天叫“张三”，明天叫“张三丰”。如果只存一个 `nickname`，改了名就找不到以前的记录了。
建议增加一张**昵称历史表**，或者简单点，在 `relations` 表里加一个字段 `alias_history`。
```sql
ALTER TABLE relations ADD COLUMN alias_history TEXT; 
-- 存储格式： "张三,张三丰,小张"
```
**逻辑**：
*   每次识别到用户 ID，检查昵称变没变。
*   如果变了，把新昵称追加到 `alias_history` 里。
*   搜索时，同时也搜索 `alias_history` 字段。
这样，用户就算问“你还记得那个张三丰吗？”（虽然他现在改名叫“小张”），AI 依然能通过历史昵称搜索到。
---
### 三、 工具定义调整
我们在给 AI 的工具定义里，要明确告诉她：**“你可以用名字或特征来查人”**。
**工具定义示例**：
```json
{
    "name": "query_relation",
    "description": "查询关于某人的记忆。输入可以是名字、绰号、或者对那个人的描述（如'那个喜欢猫的人'）。如果重名，系统会返回列表。",
    "parameters": {
        "type": "object",
        "properties": {
            "query_keyword": {
                "type": "string",
                "description": "查询关键词，如名字'张三'，或特征'喜欢打球'"
            }
        },
        "required": ["query_keyword"]
    }
}
```
---
### 四、 总结
**不需要 ID 查询！**
1.  **AI 端**：只需要提取名字（如“xxx”），调用查询工具。
2.  **后端**：利用 SQLite 的 `LIKE` 进行模糊搜索（搜昵称、搜历史昵称、搜印象描述）。
3.  **交互**：
    *   找到一个 -> 直接回答。
    *   找到多个 -> 列举出来，问用户是哪个。
    *   找不到 -> 回复不认识，并尝试引导用户介绍（介绍完正好调用 `update_relation` 记下来）。
这样体验就非常自然了，就像真人回忆一样：“哦，你说张三啊？我想想...是那个程序员张三吗？”
